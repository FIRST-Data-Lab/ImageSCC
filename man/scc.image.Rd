% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/scc.image.R
\name{scc.image}
\alias{scc.image}
\title{Simultaneous confidence corridors for mean function of imaging data}
\usage{
scc.image(Ya, Yb = NULL, Z, Z.band = NULL, d.est = 5, d.band = 2,
  r, V.est.a, Tr.est.a, V.band.a, Tr.band.a, V.est.b = NULL,
  Tr.est.b = NULL, V.band.b = NULL, Tr.band.b = NULL,
  penalty = TRUE, lambda, alpha.grid = c(0.1, 0.05, 0.01),
  adjust.sigma = TRUE)
}
\arguments{
\item{Ya}{a matrix of imaging data, each row corresponding to one subject/image.}

\item{Yb}{an optional matrix containing the second group of imaging data. Default is \code{NULL}. When \code{Yb} is \code{NULL}, a one-group SCC is constructed for the mean function of \code{Ya}, otherwise, a two-group SCC is constructed for the difference between the mean functions of \code{Yb} and \code{Ya}.}

\item{Z}{a 2-column matrix specifying locations of each pixel/voxel.}

\item{Z.band}{an optional matrix specifying locations for constructing SCC. Default is \code{NULL}. When \code{Z.band} is \code{NULL}, the SCC is evaluated on sample locations provided by matrix \code{Z}.}

\item{d.est}{degree of bivariate spline for estimating mean function, default is 5.}

\item{d.band}{degree of bivariate spline for constructing SCC, default is 2.}

\item{r}{smoothness parameter, default is 1.}

\item{V.est.a}{the 2-column matrix of vertices' coordinates in the triangulation for estimating mean function of the first set of imaging data.}

\item{Tr.est.a}{the 3-column matrix of indices of the vertices of triangles in the triangulation.}

\item{V.band.a, Tr.band.a}{information of triangultaion for constructing SCC of first set of imaging data.}

\item{V.est.b, Tr.est.b}{optional information of triangulation used for estimating mean function of the second sample.}

\item{V.band.b, Tr.band.b}{optional information of triangulation for constructing SCC of second set of imaging data.}

\item{penalty}{logical value indicating whether bivariate penalize spline should be implemented. Default is TRUE.}

\item{lambda}{the vector of the candidates of penalty parameter.}

\item{alpha.grid}{vector of confidence levels. Default is \code{c(0.1,0.05,0.01)}.}

\item{adjust.sigma}{a logical value indicating whether \eqn{\sigma(z)} is adjusted when constructing SCC. Default is TRUE.}
}
\description{
The function is used to construct SCC for mean function of one group of images or
difference between mean functions of two sets of images.
}
\details{
This R package is the implementation program for manuscript entitled "Simultaneous Confidence Corridors for Mean Functions in Functional Data Analysis of Imaging Data" by Yueying Wang, Guannan Wang, Li Wang and R. Todd Ogden.
}
\examples{
# Triangulation information;
data(Brain.V1); data(Brain.Tr1); # triangulation No. 1;
data(Brain.V2); data(Brain.Tr2); # triangulation No. 2;
V.est=Brain.V2; Tr.est=Brain.Tr2;
V.band=Brain.V1; Tr.band=Brain.Tr1;
# Location information;
n1=40; n2=40;
npix=n1*n2
u1=seq(0,1,length.out=n1)
v1=seq(0,1,length.out=n2)
uu=rep(u1,each=n2)
vv=rep(v1,times=n1)
Z=as.matrix(cbind(uu,vv))
ind.inside=inVT(V.est,Tr.est,Z[,1],Z[,2])$ind.inside
# Parameters for bivariate spline over triangulation;
d.est=5; d.band=2; r=1;

# Example 1. One-group SCC;
# simulation parameters
n=50; lam1=0.5; lam2=0.2; mu.func=2; noise.type='Func';
lambda=10^{seq(-6,3,0.5)}; alpha.grid=c(0.1,0.05,0.01);
dat=data1g.image(n,Z,ind.inside,mu.func,noise.type,lam1,lam2)
Y=dat$Y; beta.true=dat$beta.true;
out1=scc.image(Ya=Y,Z=Z,V.est.a=V.est,Tr.est.a=Tr.est,V.band.a=V.band,Tr.band.a=Tr.band,d.est=d.est,d.band=d.band,r=r,penalty=TRUE,lambda=lambda,alpha.grid=alpha.grid,adjust.sigma=TRUE)
scc=out1$scc
sum((scc[,1,2]<beta.true[ind.inside]) & (scc[,2,2]>beta.true[ind.inside]))/length(ind.inside)
plot(out1)

# Example 2. Two-group SCC;
# simulation parameters
na=50; nb=60; lam1=0.5; lam2=0.2; mu1.func=1; delta=0.3;
noise.type='Func'; lambda=10^{seq(-6,3,0.5)}; alpha.grid=c(0.10,0.05,0.01);
dat=data2g.image(na,nb,Z,ind.inside,mu1.func,noise.type,lam1,lam2,delta)
Ya=dat$Ya; Yb=dat$Yb; beta.true=dat$beta.true;
beta.diff=beta.true[,2]-beta.true[,1]
V.est.a=V.est.b=V.est;
Tr.est.a=Tr.est.b=Tr.est;
V.band.a=V.band.b=V.band;
Tr.band.a=Tr.band.b=Tr.band;
out2=scc.image(Ya=Ya,Yb=Yb,Z=Z,V.est.a=V.est.a,Tr.est.a=Tr.est.a,V.band.a=V.band.a,Tr.band.a=Tr.band.a,V.est.b=V.est.b,Tr.est.b=Tr.est.b,V.band.b=V.band.b,Tr.band.b=Tr.band.b,d.est=d.est,d.band=d.band,r=r,penalty=TRUE,lambda=lambda,alpha.grid=alpha.grid,adjust.sigma=TRUE)
scc=out2$scc
sum((scc[,1,2]<beta.diff[ind.inside]) & (scc[,2,2]>beta.diff[ind.inside]))/length(ind.inside)
plot(out2)

}
